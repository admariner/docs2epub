var run = require('./src/run');

var _ = require('lodash');
var epub = require('epub-gen');
var fs = require('fs');
var async = require('async');
var slug = require('slug');
var moment = require('moment');

const tocObjToHtml = require('./src/tocObjToHtml');

var strategyToRunId = Math.max(process.argv.indexOf('--project'), process.argv.indexOf('-p'));
var strategyToRun = strategyToRunId !== -1 && _.get(process.argv, parseInt(strategyToRunId) + 1);

if (!strategyToRun) {
  console.error('Please pass an --project argument with the ID of the project that you want to compile');
  process.exit(1);
}

console.log(`Scrapping ${strategyToRun}`);

function getEpubOptions(tocObj) {
  return {
    title: tocObj.title,
    cover: tocObj.cover,
    author: tocObj.author,
    css: 'code,pre{font-size: 0.9em;background:#fafafa;padding:0.5em;display:block;margin:0.5rem 0}',
    content: _.chain(tocObj.content)
      .filter(el => el.result)
      .map(tocEl => {
        return {
          title: tocEl.title,
          data: tocEl.result ? tocEl.result.content : ''
        };
      })
      .value()
  };
}

function execCommand(command, cb) {
  var sys = require('sys');
  var exec = require('child_process').exec;
  function puts(error, stdout, stderr) {
    if (error) throw error;
    sys.puts(stdout);
    cb();
  }
  exec(command, puts);
}

// generations trategies
function generateEpubFromHtml(tocArray) {
  var epubOptions = getEpubOptions(tocArray);
  new epub(epubOptions, 'docs/download/' + strategyToRun + '.epub');
}

function generateHtmlFromHtml(tocArray) {
  fs.writeFile('docs/download/' + strategyToRun + '.html', tocObjToHtml(tocArray), (err, res) => {
    // console.log({err, res})
  });
}

function generateEpubMetadata(docObj) {
  return new Promise(function(resolve, reject) {
    var epubMeta = `

---
title:
- type: main
  text: ${docObj.title}
creator:
- role: author
  text: ${docObj.author}
rights: ${docObj.licenceUrl}
include-before: Documentation for <b>${docObj.title}</b> ([${docObj.docsUrl}](${docObj.docsUrl})) generated by <b>docs2epub</b> ([http://javier.xyz/docs2epub/](http://javier.xyz/docs2epub/)) on ${moment().format('YYYY/MM/DD')}.
date: ${moment().format('YYYY/MM/DD')}
description: Documentation for <b>${docObj.title}</b> ([${docObj.docsUrl}](${docObj.docsUrl})) generated by <b>docs2epub</b> ([http://javier.xyz/docs2epub/](http://javier.xyz/docs2epub/)) on ${moment().format('YYYY/MM/DD')}.
...

    `;
    fs.writeFile(`_tmp/epub/${slug(docObj.title)}/meta.txt`, epubMeta, (err, res) => {
      if (err) {
        reject(err);
        return;
      }
      resolve(res);
    });
  });
}

function generateEpubFromMarkdown(docObj) {
  return new Promise(function(resolve, reject) {
    execCommand(`rm -rf _tmp/epub/${slug(docObj.title)} && mkdir -p _tmp/epub/${slug(docObj.title)}`, () => {
      async.map(
        docObj.content,
        (tocEl, cb) => {
          if (tocEl.result) {
            fs.writeFile(`_tmp/epub/${slug(docObj.title)}/${tocEl.index}.md`, tocEl.result.content, cb);
          }
        },
        (err, res) => {
          if (err) {
            reject(err);
            return;
          }
          var pandocCommand = `pandoc -s -o docs/download/${docObj.title.toLowerCase()}.epub _tmp/epub/${slug(docObj.title)}/meta.txt `;
          pandocCommand += _.map(docObj.content, tocEl => `_tmp/epub/${slug(docObj.title)}/${tocEl.index}.md `).join(
            ''
          );

          if (docObj.cover) {
            pandocCommand += `--epub-cover-image=${docObj.cover} `;
          }

          if (docObj.epubStylesheet) {
            pandocCommand += `--epub-stylesheet=${docObj.epubStylesheet} `;
          }

          if (docObj.epubTOCDepth) {
            pandocCommand += `--table-of-contents --toc-depth=${docObj.epubTOCDepth}`;
          }

          generateEpubMetadata(docObj).then(
            () => {
              execCommand(pandocCommand, () => {
                console.log('Done.');
              });
            },
            reject
          );
        }
      );
    });
  });
}

run(strategyToRun)
  .then(tocArray => {
    if (tocArray.type === 'MARKDOWN') {
      generateEpubFromMarkdown(tocArray).catch(err => console.log(err));
    } else {
      generateEpubFromHtml(tocArray);
      generateHtmlFromHtml(tocArray);
    }
  })
  .catch(err => {
    console.log(err.stack);
  });
